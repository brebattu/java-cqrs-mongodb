import com.fasterxml.jackson.core.JsonPointer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.avro.Schema;
import org.apache.avro.generic.GenericData;
import org.apache.avro.generic.GenericRecord;

import java.nio.ByteBuffer;
import java.util.*;

/**
 * Convertit un JSON "métier" en GenericRecord Avro (sans classes générées),
 * en s'appuyant uniquement sur le Schema Avro.
 *
 * Gère:
 * - RECORD / ARRAY / MAP
 * - UNION nullable: ["null", X]
 * - UNION polymorphe: A | B | C, sélection via un discriminateur dans le JSON
 *
 * Usage:
 *   GenericRecord rec = JsonBusinessToGenericRecord.convert(schema, jsonString,
 *       "/header/eventType",  // JsonPointer du discriminateur
 *       Map.of(              // mapping optionnel eventType -> recordName/fullName
 *         "PAYMENT_CREATED", "PaymentCreated",
 *         "CUSTOMER_UPDATED", "CustomerUpdated"
 *       )
 *   );
 */
public final class JsonBusinessToGenericRecord {

  private static final ObjectMapper MAPPER = new ObjectMapper();

  private JsonBusinessToGenericRecord() {}

  public static GenericRecord convert(
      Schema rootSchema,
      String businessJson,
      String discriminatorJsonPointer,
      Map<String, String> eventTypeToRecordName // peut être vide si convention
  ) throws Exception {

    JsonNode root = MAPPER.readTree(businessJson);

    Context ctx = new Context(
        root,
        JsonPointer.compile(discriminatorJsonPointer),
        eventTypeToRecordName == null ? Map.of() : eventTypeToRecordName
    );

    Object out = toAvro(rootSchema, root, ctx);
    if (!(out instanceof GenericRecord)) {
      throw new IllegalArgumentException("Le schéma racine doit être un RECORD, obtenu: " + out);
    }
    return (GenericRecord) out;
  }

  // -------------------- Core conversion --------------------

  private static Object toAvro(Schema schema, JsonNode node, Context ctx) {
    if (node == null || node.isNull()) {
      return null;
    }

    // Résolution des unions:
    if (schema.getType() == Schema.Type.UNION) {
      return toAvro(resolveUnionBranch(schema, node, ctx), node, ctx);
    }

    switch (schema.getType()) {
      case RECORD:
        return record(schema, node, ctx);

      case ARRAY:
        return array(schema, node, ctx);

      case MAP:
        return map(schema, node, ctx);

      case STRING:
        return node.asText();

      case BOOLEAN:
        return node.asBoolean();

      case INT:
        return node.asInt();

      case LONG:
        return node.asLong();

      case DOUBLE:
        return node.asDouble();

      case FLOAT:
        return (float) node.asDouble();

      case ENUM:
        return new GenericData.EnumSymbol(schema, node.asText());

      case BYTES:
        // Attendu: base64 ou texte. Ici on prend le texte brut en bytes.
        // Si tu as du base64, decode-le avant.
        return ByteBuffer.wrap(node.asText().getBytes(java.nio.charset.StandardCharsets.UTF_8));

      case NULL:
        return null;

      default:
        throw new UnsupportedOperationException("Type Avro non supporté: " + schema.getType());
    }
  }

  private static GenericRecord record(Schema recordSchema, JsonNode node, Context ctx) {
    if (!node.isObject()) {
      throw new IllegalArgumentException("Attendu OBJECT pour RECORD " + recordSchema.getFullName()
          + ", obtenu: " + node.getNodeType());
    }

    GenericRecord rec = new GenericData.Record(recordSchema);

    for (Schema.Field f : recordSchema.getFields()) {
      JsonNode child = node.get(f.name());
      Schema fieldSchema = f.schema();

      // Valeur absente: on met null (ou default si tu veux gérer les defaults)
      if (child == null || child.isMissingNode() || child.isNull()) {
        rec.put(f.name(), null);
      } else {
        rec.put(f.name(), toAvro(fieldSchema, child, ctx));
      }
    }

    return rec;
  }

  private static List<Object> array(Schema arraySchema, JsonNode node, Context ctx) {
    if (!node.isArray()) {
      throw new IllegalArgumentException("Attendu ARRAY pour " + arraySchema + ", obtenu: " + node.getNodeType());
    }
    List<Object> out = new ArrayList<>(node.size());
    Schema elemSchema = arraySchema.getElementType();
    for (JsonNode e : node) {
      out.add(toAvro(elemSchema, e, ctx));
    }
    return out;
  }

  private static Map<String, Object> map(Schema mapSchema, JsonNode node, Context ctx) {
    if (!node.isObject()) {
      throw new IllegalArgumentException("Attendu OBJECT (map) pour " + mapSchema + ", obtenu: " + node.getNodeType());
    }
    Map<String, Object> out = new HashMap<>();
    Schema valueSchema = mapSchema.getValueType();
    node.fields().forEachRemaining(e -> out.put(e.getKey(), toAvro(valueSchema, e.getValue(), ctx)));
    return out;
  }

  // -------------------- Union handling --------------------

  /**
   * Résout la branche d'union à utiliser.
   * - si union nullable simple ["null", X] -> X
   * - sinon union polymorphe A|B|C -> choisit via discriminator (eventType)
   */
  private static Schema resolveUnionBranch(Schema unionSchema, JsonNode node, Context ctx) {
    List<Schema> types = unionSchema.getTypes();

    // 1) Nullable simple ["null", X] (ou [X,"null"])
    Schema nullable = resolveNullableUnion(types);
    if (nullable != null) return nullable;

    // 2) Union polymorphe: choisir via discriminator (ex header.eventType)
    String eventType = extractEventType(ctx);
    String wantedRecord = ctx.eventTypeToRecordName.getOrDefault(eventType, eventType);

    // Matching: par fullName OU name (selon ce que tu mets dans eventType / mapping)
    for (Schema s : types) {
      if (s.getType() == Schema.Type.RECORD) {
        if (wantedRecord.equals(s.getName()) || wantedRecord.equals(s.getFullName())) {
          return s;
        }
      }
    }

    // Si tu veux être “tolérant”, tu pourrais tenter un match heuristique ici,
    // mais c'est fragile. On fail fast.
    throw new IllegalArgumentException(
        "Impossible de résoudre l'union " + unionSchema
            + " pour eventType=" + eventType
            + " (attendu record=" + wantedRecord + ")."
            + " Branches disponibles=" + recordNames(types)
    );
  }

  private static Schema resolveNullableUnion(List<Schema> types) {
    Schema nonNull = null;
    for (Schema s : types) {
      if (s.getType() == Schema.Type.NULL) continue;
      if (nonNull != null) return null; // plusieurs branches non-null => polymorphe
      nonNull = s;
    }
    return nonNull; // null si union = [null] (bizarre) ou polymorphe
  }

  private static String extractEventType(Context ctx) {
    JsonNode n = ctx.root.at(ctx.discriminatorPtr);
    if (n.isMissingNode() || n.isNull()) {
      throw new IllegalArgumentException("Discriminateur manquant à l'emplacement JSON pointer: "
          + ctx.discriminatorPtr.toString());
    }
    String v = n.asText();
    if (v == null || v.isBlank()) {
      throw new IllegalArgumentException("Discriminateur vide à l'emplacement: " + ctx.discriminatorPtr);
    }
    return v;
  }

  private static String recordNames(List<Schema> types) {
    List<String> names = new ArrayList<>();
    for (Schema s : types) {
      if (s.getType() == Schema.Type.RECORD) names.add(s.getFullName());
      else names.add(s.getType().getName());
    }
    return names.toString();
  }

  // -------------------- Context --------------------

  private static final class Context {
    final JsonNode root;
    final JsonPointer discriminatorPtr;
    final Map<String, String> eventTypeToRecordName;

    private Context(JsonNode root, JsonPointer discriminatorPtr, Map<String, String> eventTypeToRecordName) {
      this.root = root;
      this.discriminatorPtr = discriminatorPtr;
      this.eventTypeToRecordName = eventTypeToRecordName;
    }
  }
}